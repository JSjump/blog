---
title: Pointer(指针)
date: '2024-09-29'
tags: ['C语言']
draft: false
summary:  Pointer
---

# 指针定义
Pointer是一个`值`，这个值代表一个`内存地址`，因此指针相当于指向某个内存地址的路标。

字符*表示指针，通常跟在类型关键字的后面，表示指针指向的是什么类型的值。
比如，char*表示一个指向字符的指针，float*表示一个指向float类型的值的指针

```c
int* intPtr;
```

上面示例声明了一个变量intPtr，它是一个指针，指向的内存地址存放的是一个整数


# \* 运算符

`*`这个符号除了表示指针以外，还可以作为运算符，用来`取出指针变量所指向的内存地址里面的值`。
```C
void increment(int* p) {
  *p = *p + 1;
}
```

上面示例中，`函数increment()`的`参数`是一个`整数指针p`。函数体里面，`*p就表示指针p所指向的那个值`。`对*p赋值，就表示改变指针所指向的那个地址里面的值`。

上面函数的作用是将参数值加1。该函数没有返回值，因为传入的是地址，函数体内部对该地址包含的值的操作，会影响到函数外部，所以不需要返回值。事实上，`函数内部通过指针，将值传到外部，是 C 语言的常用方法`。

变量地址而不是变量值传入函数，还有一个好处。对于需要大量存储空间的大型变量，复制变量值传入函数，非常浪费时间和空间，不如传入指针来得高效。

# \& 运算符

`&`运算符用来取出一个变量所在的内存地址。

```C
int x = 1;
printf("x's address is %p\n", &x);
```
上面示例中，x是一个整数变量，`&x`就是`x的值所在的内存地址`。printf()的%p是内存地址的占位符，可以打印出内存地址。

上一小节中，参数变量加1的函数，可以像下面这样使用。

```C
void increment(int* p) {
  *p = *p + 1;
}

int x = 1;
increment(&x);
printf("%d\n", x); // 2
```

上面示例中，调用increment()函数以后，变量x的值就增加了1，原因就在于传入函数的是变量x的地址&x。

`&运算符与*运算符互为逆运算`，下面的表达式总是成立。

```C
int i = 5;

if (i == *(&i)) // 正确
```


# 指针变量的初始化

声明指针变量之后，编译器会为指针变量本身分配一个内存空间，但是这个内存空间里面的值是随机的，
也就是说，指针变量指向的值是随机的。
这时一定不能去读写指针变量指向的地址，因为那个地址是随机地址，很可能会导致严重后果。

```C
int* p;
*p = 1; // 错误
```

上面的代码是错的，因为p指向的那个地址是随机的，向这个随机地址里面写入1，会导致意想不到的结果。

正确做法是指针变量声明后，必须先让它指向一个分配好的地址，然后再进行读写，这叫做指针变量的初始化。

```C
int* p;
int i;

p = &i;
*p = 13;
```

上面示例中，`p`是指针变量，声明这个变量后，`p`会指向一个随机的内存地址。
这时要将它指向一个已经分配好的内存地址，上例就是再声明一个整数变量`i`，编译器会为`i`分配内存地址，
然后让`p`指向`i`的内存地址`（p = &i;）`。完成初始化之后，就可以对`p`指向的内存地址进行赋值了（`*p = 13;）`。

为了防止读写未初始化的指针变量，可以养成习惯，`将未初始化的指针变量设为NULL`。
```C
int* p = NULL;
```
`NULL`在 C 语言中是一个`常量`，表示`地址为0的内存空间`，这个地址是无法使用的，读写该地址会报错。


## Refernce
https://wangdoc.com/clang/pointer
