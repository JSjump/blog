---
title: 内存管理
date: '2024-10-01'
tags: ['C语言']
draft: false
summary:  内存管理
---


# C 语言的内存管理，分成两部分。

一部分是`系统管理`的，另一部分是`用户手动管理`的。

`系统管理的内存`，主要是`函数内部的变量（局部变量）`。
这部分变量在函数运行时进入内存，函数运行结束后自动从内存卸载。
这些变量存放的区域称为`”栈“（stack）`，`”栈“所在的内存是系统自动管理的`。

`用户手动管理的内存`，主要是`程序运行的整个过程中都存在的变量（全局变量）`，这些变量需要用户手动从内存释放。
如果使用后忘记释放，它就一直占用内存，直到程序退出，这种情况称为`”内存泄漏“（memory leak）`。
这些变量所在的内存称为`”堆“（heap）`，`”堆“所在的内存是用户手动管理的`。


# void指针
前面章节已经说过了，每一块内存都有地址，通过指针变量可以获取指定地址的内存块。
`指针变量必须有类型，否则编译器无法知道，如何解读内存块保存的二进制数据。`
但是，向系统请求内存的时候，有时不确定会有什么样的数据写入内存，需要先获得内存块，稍后再确定写入的数据类型。

为了满足这种需求，C 语言提供了一种`不定类型的指针`，叫做` void 指针`。
它只有内存块的地址信息，没有类型信息，等到使用该块内存的时候，再向编译器补充说明，里面的数据类型是什么。

另一方面，void 指针等同于无类型指针，可以指向任意类型的数据，但是`不能解读数据`。

`void 指针与其他所有类型指针之间是互相转换关系`，任一类型的指针都可以转为 void 指针，而 void 指针也可以转为任一类型的指针。
```C
int x = 10;

void* p = &x; // 整数指针转为 void 指针
int* q = p; // void 指针转为整数指针
```
上面示例演示了，整数指针和 void 指针如何互相转换。`&x`是一个整数指针，p是 void 指针，赋值时`&x`的地址会自动解释为 void 类型。
同样的，`p`再赋值给整数指针`q`时，`p`的地址会自动解释为整数指针。

注意，由于不知道 void 指针指向什么类型的值，所以不能用*运算符取出它指向的值。
```C
char a = 'X';
void* p = &a;

printf("%c\n", *p); // 报错
```
上面示例中，p是一个 void 指针，所以这时无法用*p取出指针指向的值。